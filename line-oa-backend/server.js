require('dotenv').config();
const express = require('express');
const app = express();
const { exec } = require("child_process");
const line = require('@line/bot-sdk');
const db = require('./db');
const productRoutes = require('./routes/ProductRoutes');
const orderRoutes = require('./routes/OrderRoutes')
const orderitemRoutes = require('./routes/OrderItemRoutes')
const ingredientRoutes = require('./routes/IngredientRoutes')
const ingredientItemRoutes = require('./routes/IngredientItemRoutes')
const cors = require('cors')
const axios = require("axios");
const cron = require("node-cron");
const { sendMenuToLine } = require("./controllers/ProductControllers");
const path = require("path");
const { deductIngredients } = require('./controllers/OrderControllers')
const FormData = require("form-data");
const fs = require("fs");




app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cors());
app.use('/api/products', productRoutes);
app.use("/uploads", express.static("uploads"));
app.use('/api/orders',orderRoutes)
app.use('/api',orderitemRoutes)
app.use('/api',ingredientRoutes)
app.use('/api',ingredientItemRoutes);


const config = {
    channelAccessToken: process.env.CHANNEL_ACCESS_TOKEN,
    channelSecret: process.env.CHANNEL_SECRET,
};

if (!config.channelAccessToken || !config.channelSecret) {
    throw new Error("Missing CHANNEL_ACCESS_TOKEN or CHANNEL_SECRET in .env file");
}

const client = new line.Client(config);
const pendingOrders = {};


app.get('/', (req, res) => {
    res.send('Hello, LINE OA is running!');
});

async function getUserProfile(userId) {
    try {
        const response = await axios.get(`https://api.line.me/v2/bot/profile/${userId}`, {
            headers: {
                "Authorization": `Bearer ${config.channelAccessToken}`
            }
        });
        return response.data;
    } catch (error) {
        console.error("Error getting user profile:", error);
        return null;
    }
}

app.post('/webhook', async (req, res) => {
    const events = req.body.events;

    for (let event of events) {
        // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤
        if (event.type === 'message' && event.message.type === "text" ) {
            let customerId = event.source.userId;
            let customerName = null;
            let customerText = event.message.text;
            

            if (event.source.type === "group") {
                customerId = event.source.groupId; // ‡πÉ‡∏ä‡πâ `groupId` ‡πÄ‡∏õ‡πá‡∏ô `Customer_id`
                customerName = "Group Chat";
                // console.log("‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≤‡∏Å Group ID:", customerId);

            } else if (event.source.type === "user") {
                customerId = event.source.userId; // ‡πÉ‡∏ä‡πâ `userId` ‡πÄ‡∏õ‡πá‡∏ô `Customer_id`
                // console.log("‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≤‡∏Å User ID:", customerId);

                //‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå
                const profile = await getUserProfile(customerId);
                if (profile) {
                    customerName = profile.displayName;
                }
            }

            try {
                // ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                await db.query(
                    `INSERT INTO Customer (Customer_id, Customer_name) 
                     VALUES (?, ?) 
                     ON DUPLICATE KEY UPDATE Customer_name = VALUES(Customer_name)`,
                    [customerId, customerName]
                );
                console.log(`‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å ${customerId} ‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢`);
                console.log(customerText);

                // ‚úÖ 2. ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å Model ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
                const modelPath = path.join(__dirname, "..", "Model", "NLP.py");
                exec(`python "${modelPath}" "${customerText}"`, async (error, stdout) => {
                    if (error) {
                        console.error("‚ùå Error running model:", error);
                        return;
                    }
                    
                    let orders;
                    try {
                        orders = JSON.parse(stdout);
                        console.log(orders)
                    } catch (parseError) {
                        console.error("‚ùå JSON Parse Error:", parseError);
                        await client.replyMessage(event.replyToken, { type: "text", text: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà" });
                        return;
                    }

                    if (!Array.isArray(orders) || orders.length === 0) {
                        return;
                    }

                    let totalAmount = 0;
                    for (let order of orders) {
                        const [rows] = await db.query("SELECT Price FROM Product WHERE Product_id = ?", [order.product_id]);
                        if (!rows.length || !rows[0].Price) continue;
                        let price = parseFloat(rows[0].Price);
                        let subtotal = price * order.quantity;
                        totalAmount += subtotal;
                    }

                    if (totalAmount === 0) {
                        return; 
                    }

                    // ‚úÖ ‡∏™‡πà‡∏á‡∏õ‡∏∏‡πà‡∏°‡πÉ‡∏´‡πâ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô
                    const confirmMessage = {
                        type: "flex",
                        altText: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠",
                        contents: {
                            type: "bubble",
                            body: {
                                type: "box",
                                layout: "vertical",
                                contents: [
                                    { type: "text", text: "‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠", weight: "bold", size: "xl" },
                                    ...orders.map(order => ({
                                        type: "text",
                                        text: `- ${order.menu} x ${order.quantity} ‡πÅ‡∏Å‡πâ‡∏ß`,
                                        wrap: true
                                    })),
                                    { type: "text", text: `‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°: ${totalAmount} ‡∏ö‡∏≤‡∏ó`, weight: "bold" }
                                ]
                            },
                            footer: {
                                type: "box",
                                layout: "horizontal",
                                spacing: "sm",
                                contents: [
                                    {
                                        type: "button",
                                        style: "primary",
                                        color: "#1DB446",
                                        action: {
                                            type: "postback",
                                            label: "Confirm",
                                            data: JSON.stringify({ action: "confirm", orders, totalAmount, customerId })
                                        }
                                    },
                                    {
                                        type: "button",
                                        style: "secondary",
                                        action: {
                                            type: "postback",
                                            label: "Cancel",
                                            data: JSON.stringify({ action: "cancel", customerId })
                                        }
                                    }
                                ]
                            }
                        }
                    };
                    
                    await client.replyMessage(event.replyToken, confirmMessage);


                });

                
                if (customerText.toLowerCase() === "‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç") {
                    // üîç ‡∏î‡∏∂‡∏á Order ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏õ‡πá‡∏ô "Preparing"
                    const [pendingOrder] = await db.query(
                        "SELECT Order_id FROM `Order` WHERE Customer_id = ? AND Status = 'Preparing' ORDER BY Order_id DESC LIMIT 1",
                        [customerId]
                    );
                
                    if (pendingOrder.length > 0) {
                        await client.replyMessage(event.replyToken, {
                            type: "text",
                            text: "üìç ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏´‡∏°‡πà‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏™‡πà‡∏á",
                        });
                
                        // ‚úÖ ‡πÄ‡∏Å‡πá‡∏ö Order_id ‡πÑ‡∏ß‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
                        pendingOrders[customerId] = pendingOrder[0].Order_id;

                    } else {
                        await client.replyMessage(event.replyToken, {
                            type: "text",
                            text: "‚õî ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÑ‡∏î‡πâ",
                        });
                    }
                }
                
                // ‚úÖ ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏´‡∏°‡πà (‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏û‡∏¥‡∏°‡∏û‡πå "‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç")
                else if (pendingOrders[customerId]) {
                    let orderId = pendingOrders[customerId];
                
                    // üîÑ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                    await db.query(
                        "UPDATE `Order` SET Customer_Address = ? WHERE Order_id = ?",
                        [customerText, orderId]
                    );
                
                    // üöÄ ‡πÅ‡∏à‡πâ‡∏á‡πÉ‡∏´‡πâ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ó‡∏£‡∏≤‡∏ö‡∏ß‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ñ‡∏π‡∏Å‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏•‡πâ‡∏ß
                    await client.replyMessage(event.replyToken, {
                        type: "text",
                        text: `üè†‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏õ‡πá‡∏ô:\n${customerText}`,
                    });
                
                    await client.pushMessage(customerId, {
                        type: "text",
                        text: `üì¶ ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ñ‡∏π‡∏Å‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢!\n‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠\n‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà ‡∏û‡∏¥‡∏°‡∏û‡πå "‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç"`,
                    });
                
                    delete pendingOrders[customerId];
                }
                
                
                
            }catch (error) {
                console.error("‚ùå Error handling order request:", error);
            }

            } else if (event.type === 'message' && event.message.type === "image") {
            const imageId = event.message.id;

            // console.log("üñºÔ∏è Image ID ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡πÑ‡∏õ‡πÇ‡∏´‡∏•‡∏î:", imageId);
            if (!imageId) {
                console.error("‚ùå Image ID ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ß‡πà‡∏≤‡∏á! ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å LINE API");
                return;
            }


                const [latestOrder] = await db.query(
                    "SELECT Order_id FROM `Order` WHERE Customer_id = ? ORDER BY Order_id DESC LIMIT 1",
                    [event.source.userId]
                );

                if (latestOrder.length === 0) {
                    return client.replyMessage(event.replyToken, { type: "text", text: "‚õî ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì" });
                }

                const orderId = latestOrder[0].Order_id;

                const resultMessage = await verifySlip(imageId, orderId, event.source.userId);
                
                await client.replyMessage(event.replyToken, {
                    type: "text",
                    text: resultMessage
                });
        }

        else if (event.type === "postback") {
            let data;
            try {
                data = JSON.parse(event.postback.data);
            } catch (error) {
                console.error("‚ùå JSON Parse Error in postback:", error);
                return;
            }

            if (data.action === "confirm") {
                try {
                    
                    
                    const [orderResult] = await db.query(
                        "INSERT INTO `Order` (Customer_id, Total_amount, Customer_Address, Status) VALUES (?, ?, ?, 'Preparing')",
                        [data.customerId, data.totalAmount, "‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤ (‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á)"]
                    );
                    const orderId = orderResult.insertId;
                    console.log(`‚úÖ Order ID ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á: ${orderId}`);

                    for (let order of data.orders) {
                        const [rows] = await db.query(
                            "SELECT Price FROM Product WHERE Product_id = ?",
                            [order.product_id]
                        );

                        if (!rows.length || !rows[0].Price) continue;
                        let price = parseFloat(rows[0].Price);
                        let subtotal = price * order.quantity;

                        console.log(`üìù ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Order_item: Order_id=${orderId}, Product_id=${order.product_id}, Quantity=${order.quantity}, Subtotal=${subtotal}`);

                        await db.query(
                            "INSERT INTO Order_item (Order_id, Product_id, Quantity, Subtotal, Status) VALUES (?, ?, ?, ?, 'Preparing')",
                            [orderId, order.product_id, order.quantity, subtotal]
                        );
                    }
                    
                    await client.replyMessage(event.replyToken, {
                        type: "text",
                        text: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏™‡πà‡∏á",
                    });
                    
        
                    // console.log("Reply Token:", event.replyToken);

                    // await client.pushMessage(data.customerId, {type: "text", text: "‚úÖ ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢!",});
            
    
                    await deductIngredients(data.orders);
                    
                    pendingOrders[data.customerId] = orderId;
                    
                    
                } catch (error) {
                    console.error("‚ùå Error saving order:", error);
                    await client.replyMessage(event.replyToken, { type: "text", text: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà" });
                }
            } else if (data.action === "cancel") {
                await client.replyMessage(event.replyToken, { type: "text", text: "‚ùå ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å" });
            } else if (data.action === "payment") {
                let paymentText = data.method === "cash" ? "üíµ ‡πÄ‡∏á‡∏¥‡∏ô‡∏™‡∏î" : "üí≥ ‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô";

                const [order] = await db.query("SELECT Total_amount FROM `Order` WHERE Order_id = ?", [data.orderId]);
            
                const amount = order[0].Total_amount;
                await db.query(
                    "INSERT INTO `Payment` (Order_id, Amount, Payment_method, Payment_date, status) VALUES (?, ?, ?, NOW(), 'Pending') " +
                    "ON DUPLICATE KEY UPDATE Payment_method = VALUES(Payment_method), status = 'Pending'",
                    [data.orderId, amount, data.method]
                );
                   
                if (data.method === "transfer") {
                    const accountDetails = `üè¶ ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô:\n\n` +
                                           `‡∏ò‡∏ô‡∏≤‡∏Ñ‡∏≤‡∏£: ‡∏Å‡∏™‡∏¥‡∏Å‡∏£‡πÑ‡∏ó‡∏¢ (KBank)\n` +
                                           `‡∏ä‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ç‡∏ä‡∏µ: ‡∏£‡πâ‡∏≤‡∏ô Juicy Vibes\n` +
                                           `‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ç‡∏ä‡∏µ: 123-4-56789-0\n\n` +
                                           `üí∞ ‡∏¢‡∏≠‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ä‡∏≥‡∏£‡∏∞: ${amount} ‡∏ö‡∏≤‡∏ó\n\n` +
                                           `üìå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡∏™‡∏•‡∏¥‡∏õ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô`;
            
                    await client.replyMessage(event.replyToken, {
                        type: "text",
                        text: accountDetails
                    });
            
                } else if (data.method === "cash" ) {
                    await client.replyMessage(event.replyToken, {
                        type: "text",
                        text: `üí∞ ‡∏¢‡∏≠‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ä‡∏≥‡∏£‡∏∞: ${amount} ‡∏ö‡∏≤‡∏ó\n\nüìå ‡πÇ‡∏õ‡∏£‡∏î‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏´‡πâ‡∏û‡∏£‡πâ‡∏≠‡∏°`
                    });

                } else {
                    await client.replyMessage(event.replyToken, {
                        type: "text",
                        text: `‚úÖ ‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏î‡πâ‡∏ß‡∏¢: ${paymentText}`
                    });
                }
            }
        }
    }

    res.sendStatus(200);
});


const downloadImage = async (imageId) => {
    const url = `https://api-data.line.me/v2/bot/message/${imageId}/content`;
    const headers = { Authorization: `Bearer ${config.channelAccessToken}` };

    try {
        console.log("üì• Downloading image from:", url);
        // console.log("üì• Sending request with headers:", headers);
        const response = await axios.get(url, { headers, responseType: "arraybuffer" });
        

        const tmpDir = path.join(__dirname, "tmp");
        if (!fs.existsSync(tmpDir)) {
            fs.mkdirSync(tmpDir, { recursive: true });
        }

        const imagePath = path.join(tmpDir, `slip-${imageId}.jpg`);
        fs.writeFileSync(imagePath, response.data);  

        return imagePath;
    } catch (error) {
        console.error("‚ùå Error downloading image:", error.response ? error.response.data.toString() : error.message);
        return null;
    }
};


// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ
const verifySlip = async (imageId, orderId, customerId) => {
    try {
        const imagePath = await downloadImage(imageId);
        if (!imagePath) {
            return "‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á‡πÉ‡∏´‡∏°‡πà";
        }

        const FormData = require("form-data");
        const formData = new FormData();
        formData.append("files", fs.createReadStream(imagePath));
        formData.append("log", "true");

        const SLIPOK_BRANCH_ID = "40471";
        const SLIPOK_API_KEY = "SLIPOKMNB83WS";

        const response = await axios.post(
            `https://api.slipok.com/api/line/apikey/${SLIPOK_BRANCH_ID}`,
            formData,
            {
                headers: {
                    "x-authorization": SLIPOK_API_KEY,
                    ...formData.getHeaders()  
                }
            }
        );

        //‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à
        fs.unlinkSync(imagePath);

        console.log("‚úÖ SlipOK Response:", response.data);

        if (response.data.success) {
            await db.query(
                "UPDATE Payment SET status = 'Confirmed' WHERE Order_id = ?",
                [orderId]
            );

            return "‚úÖ ‡∏™‡∏•‡∏¥‡∏õ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô";
        } else {
            return "‚ùå ‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á‡πÉ‡∏´‡∏°‡πà";
        }
    } catch (error) {
        console.error("‚ùå Error verifying slip:", error.response ? error.response.data : error.message);
        return `‚ùå ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ`;
    }
};

(async () => {
    try {

        const [rows] = await db.query('SHOW TABLES;');
        console.log('Connected to Database. Tables:', rows);

    } catch (err) {

        console.error('Database connection error:', err);

    }
})();

cron.schedule("0 */8 * * *", async () => {
    console.log("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡πÄ‡∏°‡∏ô‡∏π‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤...");
    try {
        await sendMenuToLine(); // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡πà‡∏á‡πÄ‡∏°‡∏ô‡∏π
    } catch (error) {
        console.error("Error sending menu:", error);
    }
}, {
    scheduled: true,
    timezone: "Asia/Bangkok" // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡πÑ‡∏ó‡∏¢
});




const PORT = 8000;
app.listen(PORT, '0.0.0.0', () => {
    console.log('Server is running on port 8000');
});

