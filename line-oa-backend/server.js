require("dotenv").config();
const express = require("express");
const app = express();
const { exec } = require("child_process");
const line = require("@line/bot-sdk");
const db = require("./db");
const productRoutes = require("./routes/ProductRoutes");
const orderRoutes = require("./routes/OrderRoutes");
const orderitemRoutes = require("./routes/OrderItemRoutes");
const ingredientRoutes = require("./routes/IngredientRoutes");
const ingredientItemRoutes = require("./routes/IngredientItemRoutes");
const cors = require("cors");
const axios = require("axios");
const cron = require("node-cron");
const { sendMenuToLine } = require("./controllers/ProductControllers");
const path = require("path");
const {
  deductIngredients,
  checkStockBeforeDeduct,
  deductIngredientsBulk,
} = require("./controllers/OrderControllers");
const fs = require("fs");
const Dashboard = require("./routes/DashboardRoutes");
const ingredient2 = require("./routes/IngredientRoutes2");
const cloudinary = require("cloudinary").v2;
const paymentroutes = require("./routes/PaymentRoutes");
const { verifySlip, CashPayment } = require("./controllers/PaymentControllers");

const swaggerUi = require('swagger-ui-express');
const swaggerJsdoc = require('swagger-jsdoc');

app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cors());
app.use("/api/products", productRoutes);
app.use("/uploads", express.static("uploads"));
app.use("/api/orders", orderRoutes);
app.use("/api", orderitemRoutes);
app.use("/api", ingredientRoutes);
app.use("/api", ingredientItemRoutes);
app.use("/api", Dashboard);
app.use("/api", ingredient2);
app.use("/api", paymentroutes);

const swaggerOptions = {
  definition: {
      openapi: "3.0.0",
      info: {
          title: "API doc",
          version: "1.0.0",
          description: "API documents",
      },
      servers: [
          {
              usl: "http://localhost:8000/",
          },
      ],
  },
  apis: ["./routes/*.js"], // ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÑ‡∏õ‡∏¢‡∏±‡∏á route files
};
const swaggerSpec = swaggerJsdoc(swaggerOptions);
app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(swaggerSpec));

const config = {
  channelAccessToken: process.env.CHANNEL_ACCESS_TOKEN,
  channelSecret: process.env.CHANNEL_SECRET,
};

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

if (!config.channelAccessToken || !config.channelSecret) {
  throw new Error(
    "Missing CHANNEL_ACCESS_TOKEN or CHANNEL_SECRET in .env file"
  );
}

const client = new line.Client(config);
const pendingOrders = {};

app.get("/", (req, res) => {
  res.send("Hello, LINE OA is running!");
});

async function getUserProfile(userId) {
  try {
    const response = await axios.get(
      `https://api.line.me/v2/bot/profile/${userId}`,
      {
        headers: {
          Authorization: `Bearer ${config.channelAccessToken}`,
        },
      }
    );
    return response.data;
  } catch (error) {
    console.error("Error getting user profile:", error);
    return null;
  }
}

app.post("/webhook", async (req, res) => {
  const events = req.body.events;

  for (let event of events) {
    // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤
    if (event.type === "message" && event.message.type === "text") {
      let customerId = event.source.userId;
      let customerName = null;
      let customerText = event.message.text;

      if (event.source.type === "group") {
        customerId = event.source.groupId; // ‡πÉ‡∏ä‡πâ `groupId` ‡πÄ‡∏õ‡πá‡∏ô `Customer_id`
        customerName = "Group Chat";
        // console.log("‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≤‡∏Å Group ID:", customerId);
      } else if (event.source.type === "user") {
        customerId = event.source.userId; // ‡πÉ‡∏ä‡πâ `userId` ‡πÄ‡∏õ‡πá‡∏ô `Customer_id`
        // console.log("‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≤‡∏Å User ID:", customerId);

        //‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÇ‡∏õ‡∏£‡πÑ‡∏ü‡∏•‡πå
        const profile = await getUserProfile(customerId);
        if (profile) {
          customerName = profile.displayName;
        }
      }

      try {
        // ‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
        await db.query(
          `INSERT INTO Customer (Customer_id, Customer_name) 
                     VALUES (?, ?) 
                     ON DUPLICATE KEY UPDATE Customer_name = VALUES(Customer_name)`,
          [customerId, customerName]
        );
        console.log(`‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å ${customerId} ‡∏•‡∏á‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢`);
        console.log(customerText);

        if (
          customerText.includes("‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ") ||
          customerText.includes("‡πÄ‡∏°‡∏ô‡∏π") ||
          customerText.includes("‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠")
        ) {
          // ‡∏™‡πà‡∏á‡πÄ‡∏°‡∏ô‡∏π‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ
          await sendMenuToLine(customerId); // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡πà‡∏á‡πÄ‡∏°‡∏ô‡∏π
        }

        // ‚úÖ 2. ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å Model ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠
        const modelPath = path.join(__dirname, ".", "Model", "NLP.py");
        exec(
          `python "${modelPath}" "${customerText}"`,
          async (error, stdout) => {
            if (error) {
              console.error("‚ùå Error running model:", error);
              return;
            }

            let orders;
            try {
              orders = JSON.parse(stdout);
              console.log(orders);
            } catch (parseError) {
              console.error("‚ùå JSON Parse Error:", parseError);
              await client.replyMessage(event.replyToken, {
                type: "text",
                text: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà",
              });
              return;
            }

            if (!Array.isArray(orders) || orders.length === 0) {
              return;
            }

            let totalAmount = 0;
            for (let order of orders) {
              const [rows] = await db.query(
                "SELECT Price FROM Product WHERE Product_id = ?",
                [order.product_id]
              );
              if (!rows.length || !rows[0].Price) continue;
              let price = parseFloat(rows[0].Price);
              let subtotal = price * order.quantity;
              totalAmount += subtotal;
            }

            if (totalAmount === 0) {
              return;
            }

            // ‚úÖ ‡∏™‡πà‡∏á‡∏õ‡∏∏‡πà‡∏°‡πÉ‡∏´‡πâ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô
            const confirmMessage = {
              type: "flex",
              altText: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠",
              contents: {
                type: "bubble",
                body: {
                  type: "box",
                  layout: "vertical",
                  contents: [
                    {
                      type: "text",
                      text: "‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠",
                      weight: "bold",
                      size: "xl",
                    },
                    ...orders.map((order) => ({
                      type: "text",
                      text: `- ${order.menu} x ${order.quantity} ‡πÅ‡∏Å‡πâ‡∏ß`,
                      wrap: true,
                    })),
                    {
                      type: "text",
                      text: `‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°: ${totalAmount} ‡∏ö‡∏≤‡∏ó`,
                      weight: "bold",
                    },
                  ],
                },
                footer: {
                  type: "box",
                  layout: "horizontal",
                  spacing: "sm",
                  contents: [
                    {
                      type: "button",
                      style: "primary",
                      color: "#1DB446",
                      action: {
                        type: "postback",
                        label: "Confirm",
                        data: JSON.stringify({
                          action: "confirm",
                          orders,
                          totalAmount,
                          customerId,
                        }),
                      },
                    },
                    {
                      type: "button",
                      style: "secondary",
                      action: {
                        type: "postback",
                        label: "Cancel",
                        data: JSON.stringify({ action: "cancel", customerId }),
                      },
                    },
                  ],
                },
              },
            };

            await client.replyMessage(event.replyToken, confirmMessage);
          }
        );

        if (customerText.toLowerCase() === "‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç") {
          // üîç ‡∏î‡∏∂‡∏á Order ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏õ‡πá‡∏ô "Preparing"
          const [pendingOrder] = await db.query(
            "SELECT Order_id FROM `Order` WHERE Customer_id = ? AND Status = 'Preparing' ORDER BY Order_id DESC LIMIT 1",
            [customerId]
          );

          if (pendingOrder.length > 0) {
            await client.replyMessage(event.replyToken, {
              type: "text",
              text: "üìç ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏´‡∏°‡πà‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏™‡πà‡∏á",
            });

            // ‚úÖ ‡πÄ‡∏Å‡πá‡∏ö Order_id ‡πÑ‡∏ß‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
            pendingOrders[customerId] = pendingOrder[0].Order_id;
          } else {
            await client.replyMessage(event.replyToken, {
              type: "text",
              text: "‚õî ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÑ‡∏î‡πâ",
            });
          }
        }

        // ‚úÖ ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏´‡∏°‡πà (‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏û‡∏¥‡∏°‡∏û‡πå "‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç")
        else if (pendingOrders[customerId]) {
          let orderId = pendingOrders[customerId];

          // üîÑ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
          await db.query(
            "UPDATE `Order` SET Customer_Address = ? WHERE Order_id = ?",
            [customerText, orderId]
          );

          // üöÄ ‡πÅ‡∏à‡πâ‡∏á‡πÉ‡∏´‡πâ‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ó‡∏£‡∏≤‡∏ö‡∏ß‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ñ‡∏π‡∏Å‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏•‡πâ‡∏ß
          await client.replyMessage(event.replyToken, {
            type: "text",
            text: `üè†‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏õ‡πá‡∏ô:\n${customerText}`,
          });

          await client.pushMessage(customerId, {
            type: "text",
            text: `üì¶ ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ñ‡∏π‡∏Å‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢!\n‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠\n‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà ‡∏û‡∏¥‡∏°‡∏û‡πå "‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç"`,
          });

          delete pendingOrders[customerId];
        }
      } catch (error) {
        console.error("‚ùå Error handling order request:", error);
      }
    } else if (event.type === "message" && event.message.type === "image") {
      const imageId = event.message.id;

      // console.log("üñºÔ∏è Image ID ‡∏ó‡∏µ‡πà‡∏™‡πà‡∏á‡πÑ‡∏õ‡πÇ‡∏´‡∏•‡∏î:", imageId);
      if (!imageId) {
        console.error("‚ùå Image ID ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ß‡πà‡∏≤‡∏á! ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å LINE API");
        return;
      }

      const [latestOrder] = await db.query(
        "SELECT Order_id FROM `Order` WHERE Customer_id = ? ORDER BY Order_id DESC LIMIT 1",
        [event.source.userId]
      );

      if (latestOrder.length === 0) {
        return client.replyMessage(event.replyToken, {
          type: "text",
          text: "‚õî ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì",
        });
      }

      const orderId = latestOrder[0].Order_id;
      const userId = event.source.userId;

      const resultMessage = await verifySlip(imageId, orderId, userId);

      await client.replyMessage(event.replyToken, {
        type: "text",
        text: resultMessage,
      });
    } else if (event.type === "postback") {

      let data;
      try {
        data = JSON.parse(event.postback.data);
      } catch (error) {
        console.error("‚ùå JSON Parse Error in postback:", error);
        return;
      }

      if (data.action === "confirm") {
        try {
          const stockCheckMsg = await checkStockBeforeDeduct(data.orders);
          if (stockCheckMsg) {
            await client.replyMessage(event.replyToken, {
              type: "text",
              text: stockCheckMsg,
            });
            return; // ‚ùå ‡∏ñ‡πâ‡∏≤‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÑ‡∏°‡πà‡∏û‡∏≠ ‡∏´‡∏¢‡∏∏‡∏î‡πÄ‡∏•‡∏¢ ‡πÑ‡∏°‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á Order
          }

          const [orderResult] = await db.query(
            "INSERT INTO `Order` (Customer_id, Total_amount, Customer_Address, Status) VALUES (?, ?, ?, 'Preparing')",
            [data.customerId, data.totalAmount, "‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤ (‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á)"]
          );
          const orderId = orderResult.insertId;
          console.log(`‚úÖ Order ID ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á: ${orderId}`);

          for (let order of data.orders) {
            const [rows] = await db.query(
              "SELECT Price FROM Product WHERE Product_id = ?",
              [order.product_id]
            );

            if (!rows.length || !rows[0].Price) continue;
            let price = parseFloat(rows[0].Price);
            let subtotal = price * order.quantity;

            console.log(
              `üìù ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Order_item: Order_id=${orderId}, Product_id=${order.product_id}, Quantity=${order.quantity}, Subtotal=${subtotal}`
            );

            await db.query(
              "INSERT INTO Order_item (Order_id, Product_id, Quantity, Subtotal, Status) VALUES (?, ?, ?, ?, 'Preparing')",
              [orderId, order.product_id, order.quantity, subtotal]
            );
            // await deductIngredientsBulk(data.orders);
            await deductIngredients(order.product_id, order.quantity);
          }

          await client.replyMessage(event.replyToken, {
            type: "text",
            text: "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏û‡∏¥‡∏°‡∏û‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏™‡πà‡∏á",
          });

          // console.log("Reply Token:", event.replyToken);

          // await client.pushMessage(data.customerId, {type: "text", text: "‚úÖ ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢!",});

          pendingOrders[data.customerId] = orderId;
        } catch (error) {
          console.error("‚ùå Error saving order:", error);
          await client.replyMessage(event.replyToken, {
            type: "text",
            text: "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà",
          });
        }
      } else if (data.action === "cancel") {
        await client.replyMessage(event.replyToken, {
          type: "text",
          text: "‚ùå ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ã‡∏∑‡πâ‡∏≠‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å",
        });
      } else if (data.action === "payment") {
        let paymentText = data.method === "cash" ? "üíµ ‡πÄ‡∏á‡∏¥‡∏ô‡∏™‡∏î" : "üí≥ ‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô";

        const [order] = await db.query(
          "SELECT Total_amount FROM `Order` WHERE Order_id = ?",
          [data.orderId]
        );

        const amount = order[0].Total_amount;
        await db.query(
          "INSERT INTO `Payment` (Order_id, Amount, Payment_method, Payment_date, status) VALUES (?, ?, ?, NOW(), 'Pending') " +
            "ON DUPLICATE KEY UPDATE Payment_method = VALUES(Payment_method), status = 'Pending'",
          [data.orderId, amount, data.method]
        );

        if (data.method === "transfer") {
          const accountDetails =
            `üè¶ ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô:\n\n` +
            `‡∏ò‡∏ô‡∏≤‡∏Ñ‡∏≤‡∏£: ‡∏Å‡∏™‡∏¥‡∏Å‡∏£‡πÑ‡∏ó‡∏¢ (KBank)\n` +
            `‡∏ä‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ç‡∏ä‡∏µ: ‡∏ü‡πâ‡∏≤‡πÉ‡∏™ ‡πÅ‡∏ï‡πâ‡∏°‡∏§‡∏ó‡∏ò‡∏¥‡πå\n` +
            `‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏ö‡∏±‡∏ç‡∏ä‡∏µ: 0883468120\n\n` +
            `üí∞ ‡∏¢‡∏≠‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ä‡∏≥‡∏£‡∏∞: ${amount} ‡∏ö‡∏≤‡∏ó\n\n` +
            `üìå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡∏™‡∏•‡∏¥‡∏õ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô`;

          await client.replyMessage(event.replyToken, {
            type: "text",
            text: accountDetails,
          });
        } else if (data.method === "cash") {
          const cashResult = await CashPayment(data.orderId, data.customerId);
          await client.replyMessage(event.replyToken, {
            type: "text",
            text: cashResult,
          });
        } else {
          await client.replyMessage(event.replyToken, {
            type: "text",
            text: `‚úÖ ‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏î‡πâ‡∏ß‡∏¢: ${paymentText}`,
          });
        }
      }
    }
  }

  res.sendStatus(200);
});

// const downloadImage = async (imageId) => {
//   const url = `https://api-data.line.me/v2/bot/message/${imageId}/content`;
//   const headers = { Authorization: `Bearer ${config.channelAccessToken}` };

//   try {
//     console.log("üì• Downloading image from:", url);
//     // console.log("üì• Sending request with headers:", headers);
//     const response = await axios.get(url, {
//       headers,
//       responseType: "arraybuffer",
//     });

//     const tmpDir = path.join(__dirname, "tmp");
//     if (!fs.existsSync(tmpDir)) {
//       fs.mkdirSync(tmpDir, { recursive: true });
//     }

//     const imagePath = path.join(tmpDir, `slip-${imageId}.jpg`);
//     fs.writeFileSync(imagePath, response.data);

//     return imagePath;
//   } catch (error) {
//     console.error(
//       "‚ùå Error downloading image:",
//       error.response ? error.response.data.toString() : error.message
//     );
//     return null;
//   }
// };

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ
// const verifySlip = async (imageId, orderId, customerId) => {
//   try {
//     const imagePath = await downloadImage(imageId);
//     if (!imagePath) {
//       return "‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á‡πÉ‡∏´‡∏°‡πà";
//     }

//     const result = await cloudinary.uploader.upload(imagePath, {
//       folder: "slips",
//     });
//     const imageUrl = result.secure_url;
//     console.log("‚úÖ URL ‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å Cloudinary:", imageUrl);

//     // ‚úÖ 1. ‡∏î‡∏∂‡∏á‡∏¢‡∏≠‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏à‡πà‡∏≤‡∏¢‡∏à‡∏≤‡∏Å DB
//     const [orderRows] = await db.query(
//       "SELECT Total_amount FROM `Order` WHERE Order_id = ?",
//       [orderId]
//     );
//     const amount = orderRows.length ? orderRows[0].Total_amount : 0;

//     const FormData = require("form-data");
//     const formData = new FormData();
//     formData.append("files", fs.createReadStream(imagePath));
//     formData.append("log", "true");
//     formData.append("amount", amount);

//     const SLIPOK_BRANCH_ID = "40471";
//     const SLIPOK_API_KEY = "SLIPOKMNB83WS";

//     const response = await axios.post(
//       `https://api.slipok.com/api/line/apikey/${SLIPOK_BRANCH_ID}`,
//       formData,
//       {
//         headers: {
//           "x-authorization": SLIPOK_API_KEY,
//           ...formData.getHeaders(),
//         },
//       }
//     );

//     const { data } = response.data;

//     fs.unlinkSync(imagePath);
//     console.log("‚úÖ SlipOK Response:", response.data);

//     if (data?.success) {
//       await db.query(
//         "UPDATE Payment SET status = 'Confirmed' WHERE Order_id = ?",
//         [orderId]
//       );

//       // ‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÄ‡∏õ‡πá‡∏ô Completed
//       await db.query(
//         "UPDATE `Order` SET status = 'Completed' WHERE Order_id = ?",
//         [orderId]
//       );

//       return "‚úÖ ‡∏™‡∏•‡∏¥‡∏õ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô";
//     } else {
//       return "‚ùå ‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á‡πÉ‡∏´‡∏°‡πà";
//     }
//   } catch (error) {
//     const errData = error?.response?.data;
//     console.error("raw error object:", error);
//     console.error("error.response:", error.response);
//     console.error("error.response.data:", errData);

//     if (errData?.code) {
//       switch (errData.code) {
//         case 1010:
//           return "‚ö†Ô∏è ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà ‡∏™‡∏•‡∏¥‡∏õ‡∏à‡∏≤‡∏Å‡∏ò‡∏ô‡∏≤‡∏Ñ‡∏≤‡∏£‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏≠‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì 5 ‡∏ô‡∏≤‡∏ó‡∏µ";
//         case 1012:
//           // ‚úÖ ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ! ‡∏î‡∏∂‡∏á timestamp ‡∏à‡∏≤‡∏Å message
//           const timestamp = errData.message?.split("‡πÄ‡∏°‡∏∑‡πà‡∏≠")[1]?.trim();
//           return `‚ùó ‡∏™‡∏•‡∏¥‡∏õ‡∏ã‡πâ‡∏≥: ‡πÄ‡∏Ñ‡∏¢‡∏™‡πà‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠ ${timestamp || "‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏ô‡∏µ‡πâ"}`;
//         case 1013:
//           return "‚ùå ‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏™‡∏•‡∏¥‡∏õ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á";
//         case 1014:
//           return "‚ùå ‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤";
//         default:
//           return `‚ùå ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô (code: ${errData.code})`;
//       }
//     }

//     return "‚ùå ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ";
//   }
// };

(async () => {
  try {
    const [rows] = await db.query("SHOW TABLES;");
    console.log("Connected to Database. Tables:", rows);
  } catch (err) {
    console.error("Database connection error:", err);
  }
})();

// cron.schedule(
//   "0 */8 * * *",
//   async () => {
//     console.log("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏á‡πÄ‡∏°‡∏ô‡∏π‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤...");
//     try {
//       await sendMenuToLine(); // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡πà‡∏á‡πÄ‡∏°‡∏ô‡∏π
//     } catch (error) {
//       console.error("Error sending menu:", error);
//     }
//   },
//   {
//     scheduled: true,
//     timezone: "Asia/Bangkok", // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡πÑ‡∏ó‡∏¢
//   }
// );

const PORT = 8000;
app.listen(PORT, "0.0.0.0", () => {
  console.log("Server is running on port 8000");
});
